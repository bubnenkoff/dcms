<template> 
    <div>
        <h1>Why-D-is-Better</h1>
	<a class="faqlink">Стоит ли начинать изучать программирование с D?</a>
<div class="content">Изучение программирования следует начинать с алгоритмизации. Тут чем проще язык, тем лучше. Однако если вы хотите изучить Си-подобный язык, то D будет правильным выбором. Синтаксис C/C++ не прост. Это отвлекает от сути. Вместо того, что бы вникать в основы программирования, приходится вникать в язык C/C++. Т.е. начиная с C/C++, вы изучаете именно C/C++, а не программирование как таковое. В этом проблема.</div>
	<a class="faqlink">Чем D лучше C#/Java?</a>
<div class="content">Основные затраты по производительности съедают виртуальные машины и run-time компиляция, поэтому и в C# и Java есть компиляторы позволяющие производить компиляцию напрямую в нативный код. D предлагает полную независимость от виртуальных машин и зачастую более простые и понятные для программиста конструкции сравнимые по краткости с Python.</div>
	<a class="faqlink"> Чем D лучше С++?</a>
<div class="content">Плюса у С++ только два. Минусы стремятся к бесконечности. C++ проектировался очень давно, на основе еще более древнего Си (который сам по себе содержит массу архитектурных решений, которые в современном мире выглядят как ошибки), метапрограмминг на шаблонах С++ вообще получился «случайно» и только потом язык стали ориентировать на эту возможность (но все равно там очень много случайных по сути решений). У D есть одно большое преимущество - в нем учтены ошибки, которые были допущены в С++. С++ не может отказаться от совместимости и местами там всё довольно криво и это уже никогда не исправить. Более того, с добавлением новых фич С++ становится сложнее выучить - ведь старые возможности никуда не деваются и о них надо знать.
Также сама концепция ООП наложенная на C++ приводит к наследованию, делегированию и расширению количества ошибок. Это способствует «маскирующему размытию» багов, которые накапливаются по экспоненте. В результате появляются fatality баги, которые можно исправить только путем очередной смены концепции/платформы.
<p>Что касается скорости разработки. Чудес не бывает, unmanaged код практически всегда будет разрабатываться медленее managed кода даже при одном и том же языке, причина — unmanaged код добавляет изрядное кол-во ручное работы по отлову багов. Можно поверить что код на unmanaged и managed языке наберут программисты примерно за одно время, но потом отладка и поиск багов в unmanaged займет значительно больше времени, просто потому что много багов при сборщике мусора просто нет.</p>
<p>Опыт показывает, что при переходе на D с C++ программисты экономят до 50% времени на написание и до 3-4 раз на отладку приложений. Особенно хорошо эта экономия видна при написании продакшен кода с жесткими сроками сдачи проекта, когда нет возможности неделями искать утечки памяти.</p></div>
	<a class="faqlink">Чем D лучше Python?</a>
<div class="content">Как сказал один разработчик в Яндексе, у меня слишком плохая память, чтобы писать на динамически типизируемом языке. Сам D хотя и имеет Си-подобный синтаксис, однако зачастую почти так же прост как и сам Python.</div>
	<a class="faqlink">Чем D лучше Rust?</a>
<div class="content">Крайне сложно представить себе реальный проект, в котором писать Rust было бы экономически оправдано. Исключение могут составлять только Embedded и hard real-time. Однако это капля в море разрабатываемого софта. На Rust нельзя написать ни одной программы, не имея хорошего понимания lifetime & ownership. Это автоматически делает его очень сложным. D в этом отношении гораздо проще и универсальнее.</div>
	<a class="faqlink">Чем D лучше Go?</a>
<div class="content">В Go простоту довели до примитивизма.</div>
	<a class="faqlink">Снижает ли производительность наличие сборщика мусора?</a>
<div class="content">Нет. В реальных проектах, а не синтетических тестах, сборщик мусора делают автоматическую оптимизацию (сборку, копирование, уплотнение объектов в памяти), что повышает производительность, а unmanaged код заставлет тоже самое делать вручную, причем в большинстве своем у программистов нет ресурсов/квалификации повторить тоже самое.

Cейчас производительность машинных кодов вообще дело десятое для 99% бизнес приложений: чтение с диска, чтение с сети, работа с БД, параллельное выполнение, dead lock'и, плохая архитектура — все куда более страшные причины, убивающие prefomance. Есть вещи, где ручное управление памятью может быть действительно  необходимо (драйвера, библиотеки игровых движкой, движки баз данных). Для таких случаев в D предусмотрена возможность полного отключения сборщика мусора.</div>
	<a class="faqlink">Зачем писать на D если на С++ уже написано миллионы строк кода?</a>
<div class="content">В реальной жизни вы не встретите ни одного серьезного приложения, которое бы базировалось на своей изначальной реализации.  Каждые 5 лет мы шагаем в новые измерения и только самый прозорливый разработчик может себе позволить код, который не выкинут через 10 лет. Поэтому не надо бояться использовать современные языки. Они позволяют вам реально сэкономить свое время.</div>
	<a class="faqlink">Подходит ли D для написания интерпрайз приложений?</a>
<div class="content">В настоящий момент бизнес логику на D пишут такие компании как Sociomantic, EMSI, Weka.IO и др. Так же D широко используется в BigData проектах в частности в биоинформатике, так как позволяет писать код эффективно работающий с большими и сверхбольшими объемами данных.</div>
</template>


<style scope>
.faqlink
{
    padding-left: 10px;
    padding-bottom: 5px;
    padding-top: 5px;
    font-size: 1.5em;
}

.content
{
    padding-left: 20px;
    padding-right: 10px;
    text-indent: 25px;
    font-size: 1.2em;
    text-align: justify;
}

</style>